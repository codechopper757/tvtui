#!/usr/bin/env python3
import curses
import json
import subprocess
import urllib.request
import datetime
import ssl
import time
from zoneinfo import ZoneInfo
from dotenv import load_dotenv
import os
from pathlib import Path

LOCAL_TZ = ZoneInfo("America/New_York")

BASE_DIR = Path(__file__).resolve().parent
load_dotenv(BASE_DIR / ".env")


HDHR_IP = os.getenv("HDHR_IP")
JELLYFIN_URL = os.getenv("JELLYFIN_URL")
JELLYFIN_API_KEY = os.getenv("JELLYFIN_API_KEY")



# ----------------------------
# Jellyfin helpers
# ----------------------------

def fetch_jellyfin_channels():
    url = f"{JELLYFIN_URL}/LiveTv/Channels?api_key={JELLYFIN_API_KEY}"
    ctx = ssl._create_unverified_context()
    try:
        with urllib.request.urlopen(url, context=ctx, timeout=4) as r:
            return json.load(r).get("Items", [])
    except:
        return []


def fetch_all_epg():
    now = datetime.datetime.utcnow()
    # Wider window to catch long programs
    start = (now - datetime.timedelta(hours=4)).isoformat() + "Z"
    end = (now + datetime.timedelta(hours=6)).isoformat() + "Z"  # Extended forward for "coming up"

    url = (
        f"{JELLYFIN_URL}/LiveTv/Programs"
        f"?StartDate={start}&EndDate={end}&Limit=5000"  # Increased limit
        f"&api_key={JELLYFIN_API_KEY}"
    )

    ctx = ssl._create_unverified_context()
    try:
        with urllib.request.urlopen(url, context=ctx, timeout=4) as r:
            return json.load(r).get("Items", [])
    except:
        return []


# ----------------------------
# HDHomeRun helpers
# ----------------------------

def fetch_channels():
    url = f"http://{HDHR_IP}/lineup.json"
    with urllib.request.urlopen(url, timeout=3) as r:
        return json.load(r)


def launch_mpv(channel):
    url = f"http://{HDHR_IP}:5004/auto/v{channel}"

    curses.def_prog_mode()
    curses.endwin()

    subprocess.Popen([
        "mpv",
        "--cache=yes",
        "--cache-secs=30",
        "--no-terminal",
        "--msg-level=all=no",
        url
    ])

    curses.reset_prog_mode()
    curses.curs_set(0)


# ----------------------------
# EPG helpers
# ----------------------------

def get_current_program(epg_cache, cid, now):
    """Find the currently playing program for a channel"""
    if not cid:
        return None
    
    for p in epg_cache:
        if p.get("ChannelId") != cid:
            continue
        try:
            start = datetime.datetime.fromisoformat(
                p["StartDate"].replace("Z", "+00:00")
            ).replace(tzinfo=None)
            end = datetime.datetime.fromisoformat(
                p["EndDate"].replace("Z", "+00:00")
            ).replace(tzinfo=None)
        except:
            continue

        if start <= now < end:
            return p
    return None


def get_upcoming_programs(epg_cache, cid, after_time, count=3):
    """Get the next N programs after a specific time"""
    if not cid:
        return []
    
    upcoming = []
    for p in epg_cache:
        if p.get("ChannelId") != cid:
            continue
        try:
            p_start = datetime.datetime.fromisoformat(
                p["StartDate"].replace("Z", "+00:00")
            ).replace(tzinfo=None)
            
            if p_start >= after_time:
                upcoming.append((p_start, p))
        except:
            continue
    
    # Sort by start time and return first N
    upcoming.sort(key=lambda x: x[0])
    return [p for _, p in upcoming[:count]]


def get_previous_program(epg_cache, cid, before_time):
    """Get the program that aired before a specific time"""
    if not cid:
        return None
    
    previous = []
    for p in epg_cache:
        if p.get("ChannelId") != cid:
            continue
        try:
            p_end = datetime.datetime.fromisoformat(
                p["EndDate"].replace("Z", "+00:00")
            ).replace(tzinfo=None)
            
            if p_end <= before_time:
                previous.append((p_end, p))
        except:
            continue
    
    # Sort by end time and return the most recent
    if previous:
        previous.sort(key=lambda x: x[0], reverse=True)
        return previous[0][1]
    return None


# ----------------------------
# UI helpers
# ----------------------------

def init_colors():
    curses.start_color()
    curses.use_default_colors()

    curses.init_pair(1, curses.COLOR_CYAN, -1)     # header
    curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_CYAN)  # selected
    curses.init_pair(3, curses.COLOR_GREEN, -1)    # channels
    curses.init_pair(4, curses.COLOR_YELLOW, -1)   # footer
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)  # border
    curses.init_pair(6, curses.COLOR_WHITE, -1)    # info text

    curses.init_pair(7, curses.COLOR_GREEN, -1)    # progress early
    curses.init_pair(8, curses.COLOR_YELLOW, -1)   # progress mid
    curses.init_pair(9, curses.COLOR_RED, -1)      # progress late
    curses.init_pair(10, curses.COLOR_BLUE, -1)    # timeline markers
    
    # Genre colors
    curses.init_pair(11, curses.COLOR_GREEN, -1)   # Sports
    curses.init_pair(12, curses.COLOR_BLUE, -1)    # Movies
    curses.init_pair(13, curses.COLOR_YELLOW, -1)  # News
    curses.init_pair(14, curses.COLOR_MAGENTA, -1) # Drama/Series
    curses.init_pair(15, curses.COLOR_CYAN, -1)    # Kids/Family
    curses.init_pair(16, curses.COLOR_RED, -1)     # Reality


def draw_box(win, color):
    win.attron(curses.color_pair(color))
    win.box()
    win.attroff(curses.color_pair(color))


def draw_progress_bar(win, y, x, pct, width):
    filled = int(width * pct)

    if pct < 0.5:
        color = curses.color_pair(7)
    elif pct < 0.85:
        color = curses.color_pair(8)
    else:
        color = curses.color_pair(9)

    win.addstr(y, x, "[")

    win.attron(color)
    win.addstr(y, x + 1, "█" * filled)
    win.attroff(color)

    win.addstr(y, x + 1 + filled, "░" * (width - filled))
    win.addstr(y, x + width + 1, "]")


def get_genre_color(genres):
    """Return color pair based on program genre"""
    if not genres:
        return 6  # default white
    
    # genres can be a list or a string
    genre_str = " ".join(genres).lower() if isinstance(genres, list) else str(genres).lower()
    
    if any(g in genre_str for g in ["sport", "football", "basketball", "baseball", "soccer", "hockey"]):
        return 11  # Green
    elif any(g in genre_str for g in ["movie", "film"]):
        return 12  # Blue
    elif any(g in genre_str for g in ["news", "weather"]):
        return 13  # Yellow
    elif any(g in genre_str for g in ["drama", "series", "comedy", "sitcom"]):
        return 14  # Magenta
    elif any(g in genre_str for g in ["kids", "children", "family", "animation"]):
        return 15  # Cyan
    elif any(g in genre_str for g in ["reality", "game show", "talk show"]):
        return 16  # Red
    else:
        return 6  # default white


def format_countdown(seconds):
    """Format seconds into HH:MM:SS or MM:SS"""
    if seconds < 0:
        return "00:00"
    
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    
    if hours > 0:
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"
    else:
        return f"{minutes:02d}:{secs:02d}"


def truncate_text(text, max_len):
    """Truncate text to max length with ellipsis"""
    if len(text) <= max_len:
        return text
    return text[:max_len-3] + "..."


# ----------------------------
# Main UI
# ----------------------------

def main(stdscr):
    curses.curs_set(0)
    stdscr.keypad(True)
    stdscr.timeout(1000)  # Refresh every second for countdown timer
    init_colors()

    channels = fetch_channels()
    selected = 0
    scroll = 0

    epg_cache = []
    last_epg_fetch = 0
    channel_id_map = {}
    
    # Cache current programs for all channels for preview
    channel_programs_cache = {}

    while True:
        stdscr.clear()
        h, w = stdscr.getmaxyx()

        now = datetime.datetime.utcnow()

        # Refresh EPG and channel mapping every 30 seconds
        if time.time() - last_epg_fetch > 30:
            epg_cache = fetch_all_epg()
            last_epg_fetch = time.time()
            
            # Refresh channel mapping when we refresh EPG
            channel_id_map = {}
            for c in fetch_jellyfin_channels():
                if c.get("Number") and c.get("Id"):
                    channel_id_map[c["Number"]] = c["Id"]
            
            # Cache current programs for all channels
            channel_programs_cache = {}
            for ch in channels:
                cid = channel_id_map.get(ch["GuideNumber"])
                if cid:
                    prog = get_current_program(epg_cache, cid, now)
                    if prog:
                        channel_programs_cache[ch["GuideNumber"]] = prog.get("Name", "")

        title = " HDHomeRun Live TV Dashboard "
        stdscr.attron(curses.color_pair(1) | curses.A_BOLD)
        stdscr.addnstr(0, (w - len(title)) // 2, title, w - 2)
        stdscr.attroff(curses.color_pair(1) | curses.A_BOLD)

        pane_width = w // 2

        left = stdscr.derwin(h - 2, pane_width, 1, 0)
        right = stdscr.derwin(h - 2, w - pane_width, 1, pane_width)

        draw_box(left, 5)
        draw_box(right, 5)

        # Left pane header
        left.attron(curses.color_pair(1))
        left.addnstr(0, 2, " Channels ", pane_width - 4)
        left.attroff(curses.color_pair(1))

        view_height = h - 6

        if selected < scroll:
            scroll = selected
        elif selected >= scroll + view_height:
            scroll = selected - view_height + 1

        # Display channels with current program preview
        for idx in range(scroll, min(scroll + view_height, len(channels))):
            y = idx - scroll + 1
            ch = channels[idx]
            
            # Get current program for this channel (from cache)
            current_prog = channel_programs_cache.get(ch["GuideNumber"], "")
            
            # Format: "3.1  ABC     | Now: Program Name"
            max_name_len = 20
            max_prog_len = pane_width - max_name_len - 15
            
            ch_name = truncate_text(ch['GuideName'], max_name_len)
            prog_preview = truncate_text(current_prog, max_prog_len) if current_prog else ""
            
            if prog_preview:
                line = f"{ch['GuideNumber']:>6}  {ch_name:<{max_name_len}} │ {prog_preview}"
            else:
                line = f"{ch['GuideNumber']:>6}  {ch_name}"

            if idx == selected:
                left.attron(curses.color_pair(2))
                left.addnstr(y, 2, line.ljust(pane_width - 4), pane_width - 4)
                left.attroff(curses.color_pair(2))
            else:
                left.attron(curses.color_pair(3))
                left.addnstr(y, 2, line, pane_width - 4)
                left.attroff(curses.color_pair(3))

        # Right pane header
        right.attron(curses.color_pair(1))
        right.addnstr(0, 2, " Now Playing ", w - pane_width - 4)
        right.attroff(curses.color_pair(1))

        ch = channels[selected]
        cid = channel_id_map.get(ch["GuideNumber"])
        
        program = get_current_program(epg_cache, cid, now)
        
        info_lines = [
            f"Channel: {ch['GuideNumber']}",
            f"Name: {ch['GuideName']}",
            "",
        ]

        pct = 0
        remaining_sec = 0

        if program:
            title_txt = program.get("Name", "Unknown")

            start_dt = datetime.datetime.fromisoformat(program["StartDate"].replace("Z",""))
            end_dt = datetime.datetime.fromisoformat(program["EndDate"].replace("Z",""))

            local_start = start_dt.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)
            local_end   = end_dt.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)

            total_sec = (end_dt - start_dt).total_seconds()
            elapsed_sec = (now - start_dt).total_seconds()
            remaining_sec = (end_dt - now).total_seconds()

            pct = min(max(elapsed_sec / total_sec, 0), 1)

            info_lines += [
                "Now Playing:",
                title_txt,
                "",
                f"Ends in: {format_countdown(remaining_sec)}",
                f"Start: {local_start.strftime('%I:%M %p')}",
                f"End:   {local_end.strftime('%I:%M %p')}",
            ]
            
            # Mini Timeline at the bottom with visual tree
            prev_prog = get_previous_program(epg_cache, cid, start_dt)
            timeline_y = h - 8
            
            if timeline_y > len(info_lines) + 3:
                info_lines.append("")
                info_lines.append("━━━━━ Timeline ━━━━━")
                
                # Previous program
                if prev_prog:
                    prev_name = truncate_text(prev_prog.get("Name", ""), 25)
                    prev_end = datetime.datetime.fromisoformat(
                        prev_prog["EndDate"].replace("Z", "+00:00")
                    ).replace(tzinfo=None)
                    prev_local_end = prev_end.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)
                    info_lines.append(f"  ┌─ Previously:")
                    info_lines.append(f"  │  {prev_name}")
                    info_lines.append(f"  │  Ended: {prev_local_end.strftime('%I:%M %p')}")
                    info_lines.append(f"  │")
                
                # Current program (with color coding)
                info_lines.append(f"  ├─► NOW PLAYING:")
                curr_display = f"  │   {truncate_text(title_txt, 25)}"
                info_lines.append(curr_display)
                info_lines.append(f"  │   Progress: {int(pct*100)}% [{format_countdown(remaining_sec)} left]")
                info_lines.append(f"  │")
                
                # Next program
                upcoming = get_upcoming_programs(epg_cache, cid, end_dt, count=1)
                if upcoming:
                    next_prog = upcoming[0]
                    next_name = truncate_text(next_prog.get("Name", ""), 25)
                    next_start = datetime.datetime.fromisoformat(
                        next_prog["StartDate"].replace("Z", "+00:00")
                    ).replace(tzinfo=None)
                    next_local_start = next_start.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)
                    info_lines.append(f"  └─► Up Next:")
                    info_lines.append(f"     {next_name}")
                    info_lines.append(f"     Starts: {next_local_start.strftime('%I:%M %p')}")
            
            # Show additional upcoming programs after timeline
            upcoming = get_upcoming_programs(epg_cache, cid, end_dt, count=3)
            if len(upcoming) > 1:
                info_lines.append("")
                info_lines.append("Coming Up Later:")
                for i, up in enumerate(upcoming[1:], start=2):  # Skip first (already in timeline)
                    up_title = truncate_text(up.get("Name", "Unknown"), w - pane_width - 10)
                    up_start = datetime.datetime.fromisoformat(
                        up["StartDate"].replace("Z", "+00:00")
                    ).replace(tzinfo=None)
                    up_local = up_start.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)
                    info_lines.append(f"  {up_local.strftime('%I:%M %p')} - {up_title}")
        else:
            info_lines += ["Now Playing:", "No data"]

        right.attron(curses.color_pair(6))
        for i, line in enumerate(info_lines):
            if i + 2 < h - 3:
                # Highlight the program title
                if program and i == 4:  # "Now Playing:" title line
                    right.attron(curses.A_BOLD)
                    right.addnstr(i + 2, 2, line, w - pane_width - 4)
                    right.attroff(curses.A_BOLD)
                else:
                    right.addnstr(i + 2, 2, line, w - pane_width - 4)
        right.attroff(curses.color_pair(6))

        if program:
            bar_y = 2 + 3
            # clear the whole line first
            right.move(bar_y, 1)
            right.clrtoeol()

            label = "Progress:"
            right.addstr(bar_y, 2, label)

            bar_x = 2 + len(label) + 1
            draw_progress_bar(right, bar_y, bar_x, pct, 22)
            right.addstr(bar_y, bar_x + 24, f"{int(pct*100)}%")


        footer = " ↑↓ Navigate   ENTER Watch   q Quit "
        stdscr.attron(curses.color_pair(4))
        stdscr.addnstr(h - 1, 2, footer.ljust(w - 4), w - 4)
        stdscr.attroff(curses.color_pair(4))

        key = stdscr.getch()

        if key in (ord('q'), 27):
            break
        elif key == curses.KEY_UP:
            selected = max(0, selected - 1)
        elif key == curses.KEY_DOWN:
            selected = min(len(channels) - 1, selected + 1)
        elif key in (10, 13):
            launch_mpv(channels[selected]["GuideNumber"])

        stdscr.refresh()


if __name__ == "__main__":
    curses.wrapper(main)
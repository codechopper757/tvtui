#!/usr/bin/env python3
import curses
import json
import subprocess
import urllib.request
import datetime
import ssl
import time
from zoneinfo import ZoneInfo
from dotenv import load_dotenv
import os
from pathlib import Path
MPV_PROCESS = None
CURRENT_CHANNEL = None
LAST_CHANNEL = None


LOCAL_TZ = ZoneInfo("America/New_York")

BASE_DIR = Path(__file__).resolve().parent
load_dotenv(BASE_DIR / ".env")


HDHR_IP = os.getenv("HDHR_IP")
JELLYFIN_URL = os.getenv("JELLYFIN_URL")
JELLYFIN_API_KEY = os.getenv("JELLYFIN_API_KEY")



# ----------------------------
# Jellyfin helpers
# ----------------------------

def fetch_jellyfin_channels():
    url = f"{JELLYFIN_URL}/LiveTv/Channels?api_key={JELLYFIN_API_KEY}"
    ctx = ssl._create_unverified_context()
    try:
        with urllib.request.urlopen(url, context=ctx, timeout=4) as r:
            return json.load(r).get("Items", [])
    except:
        return []


def fetch_all_epg():
    now = datetime.datetime.utcnow()
    # Wider window to catch long programs
    start = (now - datetime.timedelta(hours=4)).isoformat() + "Z"
    end = (now + datetime.timedelta(hours=6)).isoformat() + "Z"  # Extended forward for "coming up"

    url = (
        f"{JELLYFIN_URL}/LiveTv/Programs"
        f"?StartDate={start}&EndDate={end}&Limit=5000"  # Increased limit
        f"&api_key={JELLYFIN_API_KEY}"
    )

    ctx = ssl._create_unverified_context()
    try:
        with urllib.request.urlopen(url, context=ctx, timeout=4) as r:
            return json.load(r).get("Items", [])
    except:
        return []


# ----------------------------
# HDHomeRun helpers
# ----------------------------

def fetch_channels():
    url = f"http://{HDHR_IP}/lineup.json"
    with urllib.request.urlopen(url, timeout=3) as r:
        return json.load(r)

def launch_mpv(channel):
    global MPV_PROCESS, CURRENT_CHANNEL, LAST_CHANNEL

    url = f"http://{HDHR_IP}:5004/auto/v{channel}"

    curses.def_prog_mode()
    curses.endwin()

    # Update channel history
    if CURRENT_CHANNEL is not None and CURRENT_CHANNEL != channel:
        LAST_CHANNEL = CURRENT_CHANNEL
    CURRENT_CHANNEL = channel

    # Kill previous mpv if running
    if MPV_PROCESS and MPV_PROCESS.poll() is None:
        MPV_PROCESS.terminate()
        try:
            MPV_PROCESS.wait(timeout=2)
        except:
            MPV_PROCESS.kill()

    MPV_PROCESS = subprocess.Popen([
        "mpv",
        "--cache=yes",
        "--cache-secs=30",
        "--no-terminal",
        "--msg-level=all=no",
        "--save-position-on-quit",
        url
    ])

    curses.reset_prog_mode()
    curses.curs_set(0)




# ----------------------------
# EPG helpers
# ----------------------------

def get_current_program(epg_cache, cid, now):
    """Find the currently playing program for a channel"""
    if not cid:
        return None
    
    for p in epg_cache:
        if p.get("ChannelId") != cid:
            continue
        try:
            start = datetime.datetime.fromisoformat(
                p["StartDate"].replace("Z", "+00:00")
            ).replace(tzinfo=None)
            end = datetime.datetime.fromisoformat(
                p["EndDate"].replace("Z", "+00:00")
            ).replace(tzinfo=None)
        except:
            continue

        if start <= now < end:
            return p
    return None


def get_upcoming_programs(epg_cache, cid, after_time, count=3):
    """Get the next N programs after a specific time"""
    if not cid:
        return []
    
    upcoming = []
    for p in epg_cache:
        if p.get("ChannelId") != cid:
            continue
        try:
            p_start = datetime.datetime.fromisoformat(
                p["StartDate"].replace("Z", "+00:00")
            ).replace(tzinfo=None)
            
            if p_start >= after_time:
                upcoming.append((p_start, p))
        except:
            continue
    
    # Sort by start time and return first N
    upcoming.sort(key=lambda x: x[0])
    return [p for _, p in upcoming[:count]]


def get_previous_program(epg_cache, cid, before_time):
    """Get the program that aired before a specific time"""
    if not cid:
        return None
    
    previous = []
    for p in epg_cache:
        if p.get("ChannelId") != cid:
            continue
        try:
            p_end = datetime.datetime.fromisoformat(
                p["EndDate"].replace("Z", "+00:00")
            ).replace(tzinfo=None)
            
            if p_end <= before_time:
                previous.append((p_end, p))
        except:
            continue
    
    # Sort by end time and return the most recent
    if previous:
        previous.sort(key=lambda x: x[0], reverse=True)
        return previous[0][1]
    return None


# ----------------------------
# UI helpers
# ----------------------------

def init_colors():
    curses.start_color()
    curses.use_default_colors()

    curses.init_pair(1, curses.COLOR_CYAN, -1)     # header
    curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_CYAN)  # selected
    curses.init_pair(3, curses.COLOR_GREEN, -1)    # channels
    curses.init_pair(4, curses.COLOR_YELLOW, -1)   # footer
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)  # border
    curses.init_pair(6, curses.COLOR_WHITE, -1)    # info text

    curses.init_pair(7, curses.COLOR_GREEN, -1)    # progress early
    curses.init_pair(8, curses.COLOR_YELLOW, -1)   # progress mid
    curses.init_pair(9, curses.COLOR_RED, -1)      # progress late
    curses.init_pair(10, curses.COLOR_BLUE, -1)    # timeline markers
    
    # Genre colors (keeping for future use)
    curses.init_pair(11, curses.COLOR_GREEN, -1)   # Sports
    curses.init_pair(12, curses.COLOR_BLUE, -1)    # Movies
    curses.init_pair(13, curses.COLOR_YELLOW, -1)  # News
    curses.init_pair(14, curses.COLOR_MAGENTA, -1) # Drama/Series
    curses.init_pair(15, curses.COLOR_CYAN, -1)    # Kids/Family
    curses.init_pair(16, curses.COLOR_RED, -1)     # Reality
    
    # Timeline colors
    curses.init_pair(17, 240, -1)                  # Previous (dim gray) - may not work on all terminals
    curses.init_pair(18, curses.COLOR_GREEN, -1)   # NOW PLAYING (bright green)
    curses.init_pair(19, curses.COLOR_CYAN, -1)    # Up Next (cyan)


def draw_box(win, color):
    win.attron(curses.color_pair(color))
    win.box()
    win.attroff(curses.color_pair(color))


def draw_progress_bar(win, y, x, pct, width):
    filled = int(width * pct)

    if pct < 0.5:
        color = curses.color_pair(7)
    elif pct < 0.85:
        color = curses.color_pair(8)
    else:
        color = curses.color_pair(9)

    win.addstr(y, x, "[")

    win.attron(color)
    win.addstr(y, x + 1, "█" * filled)
    win.attroff(color)

    win.addstr(y, x + 1 + filled, "░" * (width - filled))
    win.addstr(y, x + width + 1, "]")


def get_genre_color(genres):
    """Return color pair based on program genre"""
    if not genres:
        return 6  # default white
    
    # genres can be a list or a string
    genre_str = " ".join(genres).lower() if isinstance(genres, list) else str(genres).lower()
    
    if any(g in genre_str for g in ["sport", "football", "basketball", "baseball", "soccer", "hockey"]):
        return 11  # Green
    elif any(g in genre_str for g in ["movie", "film"]):
        return 12  # Blue
    elif any(g in genre_str for g in ["news", "weather"]):
        return 13  # Yellow
    elif any(g in genre_str for g in ["drama", "series", "comedy", "sitcom"]):
        return 14  # Magenta
    elif any(g in genre_str for g in ["kids", "children", "family", "animation"]):
        return 15  # Cyan
    elif any(g in genre_str for g in ["reality", "game show", "talk show"]):
        return 16  # Red
    else:
        return 6  # default white


def format_countdown(seconds):
    """Format seconds into HH:MM:SS or MM:SS"""
    if seconds < 0:
        return "00:00"
    
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    
    if hours > 0:
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"
    else:
        return f"{minutes:02d}:{secs:02d}"


def truncate_text(text, max_len):
    """Truncate text to max length with ellipsis"""
    if len(text) <= max_len:
        return text
    return text[:max_len-3] + "..."


# ----------------------------
# Main UI
# ----------------------------

def main(stdscr):
    curses.curs_set(0)
    stdscr.keypad(True)
    stdscr.timeout(1000)  # Refresh every second for countdown timer
    init_colors()

    channels = fetch_channels()
    selected = 0
    scroll = 0

    epg_cache = []
    last_epg_fetch = 0
    channel_id_map = {}
    
    # Cache current programs for all channels for preview
    channel_programs_cache = {}
    
    # Search state
    search_mode = False
    search_query = ""
    filtered_channels = channels[:]  # Copy of channels list

    while True:
        stdscr.clear()
        h, w = stdscr.getmaxyx()

        now = datetime.datetime.utcnow()

        # Refresh EPG and channel mapping every 30 seconds
        if time.time() - last_epg_fetch > 30:
            epg_cache = fetch_all_epg()
            last_epg_fetch = time.time()
            
            # Refresh channel mapping when we refresh EPG
            channel_id_map = {}
            for c in fetch_jellyfin_channels():
                if c.get("Number") and c.get("Id"):
                    channel_id_map[c["Number"]] = c["Id"]
            
            # Cache current programs for all channels
            channel_programs_cache = {}
            for ch in channels:
                cid = channel_id_map.get(ch["GuideNumber"])
                if cid:
                    prog = get_current_program(epg_cache, cid, now)
                    if prog:
                        channel_programs_cache[ch["GuideNumber"]] = prog.get("Name", "")

        title = " HDHomeRun Live TV Dashboard "
        stdscr.attron(curses.color_pair(1) | curses.A_BOLD)
        stdscr.addnstr(0, (w - len(title)) // 2, title, w - 2)
        stdscr.attroff(curses.color_pair(1) | curses.A_BOLD)

        pane_width = w // 2

        left = stdscr.derwin(h - 2, pane_width, 1, 0)
        right = stdscr.derwin(h - 2, w - pane_width, 1, pane_width)

        draw_box(left, 5)
        draw_box(right, 5)

        # Left pane header
        left.attron(curses.color_pair(1))
        left.addnstr(0, 2, " Channels ", pane_width - 4)
        left.attroff(curses.color_pair(1))

        view_height = h - 6

        if selected < scroll:
            scroll = selected
        elif selected >= scroll + view_height:
            scroll = selected - view_height + 1

        # Display channels with current program preview
        display_channels = filtered_channels if search_mode or search_query else channels
        
        for idx in range(scroll, min(scroll + view_height, len(display_channels))):
            y = idx - scroll + 1
            ch = display_channels[idx]
            
            # Get current program for this channel (from cache)
            current_prog = channel_programs_cache.get(ch["GuideNumber"], "")
            
            # Format with three-part coloring
            max_name_len = 20
            max_prog_len = pane_width - max_name_len - 15
            
            ch_num = f"{ch['GuideNumber']:>6}"
            ch_name = truncate_text(ch['GuideName'], max_name_len)
            prog_preview = truncate_text(current_prog, max_prog_len) if current_prog else ""

            if idx == selected:
                # Selected row - use highlight background
                left.attron(curses.color_pair(2))
                if prog_preview:
                    line = f"{ch_num}  {ch_name:<{max_name_len}} │ {prog_preview}"
                else:
                    line = f"{ch_num}  {ch_name}"
                left.addnstr(y, 2, line.ljust(pane_width - 4), pane_width - 4)
                left.attroff(curses.color_pair(2))
            else:
                # Non-selected row - use three-part coloring
                x_pos = 2
                
                # Channel number in cyan
                left.attron(curses.color_pair(1))  # Cyan
                left.addnstr(y, x_pos, ch_num, len(ch_num))
                left.attroff(curses.color_pair(1))
                x_pos += len(ch_num) + 2
                
                # Channel name in white
                left.attron(curses.color_pair(6))  # White
                left.addnstr(y, x_pos, ch_name, max_name_len)
                left.attroff(curses.color_pair(6))
                x_pos += max_name_len
                
                # Current program in yellow (if available)
                if prog_preview:
                    separator = " │ "
                    left.addstr(y, x_pos, separator)
                    x_pos += len(separator)
                    
                    left.attron(curses.color_pair(4))  # Yellow
                    left.addnstr(y, x_pos, prog_preview, max_prog_len)
                    left.attroff(curses.color_pair(4))

        # Right pane header
        right.attron(curses.color_pair(1))
        right.addnstr(0, 2, " Now Playing ", w - pane_width - 4)
        right.attroff(curses.color_pair(1))

        ch = display_channels[selected]
        cid = channel_id_map.get(ch["GuideNumber"])
        
        program = get_current_program(epg_cache, cid, now)
        
        info_lines = [
            f"Channel: {ch['GuideNumber']}",
            f"Name: {ch['GuideName']}",
            "",
        ]

        pct = 0
        remaining_sec = 0

        if program:
            title_txt = program.get("Name", "Unknown")

            start_dt = datetime.datetime.fromisoformat(program["StartDate"].replace("Z",""))
            end_dt = datetime.datetime.fromisoformat(program["EndDate"].replace("Z",""))

            local_start = start_dt.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)
            local_end   = end_dt.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)

            total_sec = (end_dt - start_dt).total_seconds()
            elapsed_sec = (now - start_dt).total_seconds()
            remaining_sec = (end_dt - now).total_seconds()

            pct = min(max(elapsed_sec / total_sec, 0), 1)

            info_lines += [
                "Now Playing:",
                title_txt,
                "",
                f"Ends in: {format_countdown(remaining_sec)}",
                f"Start: {local_start.strftime('%I:%M %p')}",
                f"End:   {local_end.strftime('%I:%M %p')}",
            ]
            
            # Mini Timeline at the bottom with visual tree
            prev_prog = get_previous_program(epg_cache, cid, start_dt)
            timeline_y = h - 8
            
            if timeline_y > len(info_lines) + 3:
                info_lines.append("")
                info_lines.append("━━━━━ Timeline ━━━━━")
                
                # Store lines with color info: (line_text, color_pair)
                timeline_lines = []
                
                # Previous program (dim)
                if prev_prog:
                    prev_name = truncate_text(prev_prog.get("Name", ""), 25)
                    prev_end = datetime.datetime.fromisoformat(
                        prev_prog["EndDate"].replace("Z", "+00:00")
                    ).replace(tzinfo=None)
                    prev_local_end = prev_end.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)
                    timeline_lines.append(("  ┌─ Previously:", 17))
                    timeline_lines.append((f"  │  {prev_name}", 17))
                    timeline_lines.append((f"  │  Ended: {prev_local_end.strftime('%I:%M %p')}", 17))
                    timeline_lines.append(("  │", 17))
                
                # Current program (bright green)
                timeline_lines.append(("  ├─► NOW PLAYING:", 18))
                curr_display = f"  │   {truncate_text(title_txt, 25)}"
                timeline_lines.append((curr_display, 18))
                timeline_lines.append((f"  │   Progress: {int(pct*100)}% [{format_countdown(remaining_sec)} left]", 18))
                timeline_lines.append(("  │", 18))
                
                # Next program (cyan)
                upcoming = get_upcoming_programs(epg_cache, cid, end_dt, count=1)
                if upcoming:
                    next_prog = upcoming[0]
                    next_name = truncate_text(next_prog.get("Name", ""), 25)
                    next_start = datetime.datetime.fromisoformat(
                        next_prog["StartDate"].replace("Z", "+00:00")
                    ).replace(tzinfo=None)
                    next_local_start = next_start.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)
                    timeline_lines.append(("  └─► Up Next:", 19))
                    timeline_lines.append((f"     {next_name}", 19))
                    timeline_lines.append((f"     Starts: {next_local_start.strftime('%I:%M %p')}", 19))
                
                # Add colored timeline lines to info_lines as tuples
                for line_text, color in timeline_lines:
                    info_lines.append((line_text, color))
            
            # Show additional upcoming programs after timeline
            upcoming = get_upcoming_programs(epg_cache, cid, end_dt, count=3)
            if len(upcoming) > 1:
                info_lines.append("")
                info_lines.append("Coming Up Later:")
                for i, up in enumerate(upcoming[1:], start=2):  # Skip first (already in timeline)
                    up_title = truncate_text(up.get("Name", "Unknown"), w - pane_width - 10)
                    up_start = datetime.datetime.fromisoformat(
                        up["StartDate"].replace("Z", "+00:00")
                    ).replace(tzinfo=None)
                    up_local = up_start.replace(tzinfo=datetime.timezone.utc).astimezone(LOCAL_TZ)
                    info_lines.append(f"  {up_local.strftime('%I:%M %p')} - {up_title}")
        else:
            info_lines += ["Now Playing:", "No data"]

        right.attron(curses.color_pair(6))
        for i, line in enumerate(info_lines):
            if i + 2 < h - 3:
                # Check if line is a tuple with color info
                if isinstance(line, tuple):
                    line_text, color_pair = line
                    right.attron(curses.color_pair(color_pair) | curses.A_BOLD)
                    right.addnstr(i + 2, 2, line_text, w - pane_width - 4)
                    right.attroff(curses.color_pair(color_pair) | curses.A_BOLD)
                # Highlight the program title
                elif program and i == 4:  # "Now Playing:" title line
                    right.attron(curses.A_BOLD)
                    right.addnstr(i + 2, 2, line, w - pane_width - 4)
                    right.attroff(curses.A_BOLD)
                else:
                    right.addnstr(i + 2, 2, line, w - pane_width - 4)
        right.attroff(curses.color_pair(6))

        if program:
            bar_y = 2 + 3
            # clear the whole line first
            right.move(bar_y, 1)
            right.clrtoeol()

            label = "Progress:"
            right.addstr(bar_y, 2, label)

            bar_x = 2 + len(label) + 1
            draw_progress_bar(right, bar_y, bar_x, pct, 22)
            right.addstr(bar_y, bar_x + 24, f"{int(pct*100)}%")

        footer = " ↑↓ Navigate   ENTER Watch   b Last Channel   / Search   ESC Clear   q Quit "

        stdscr.attron(curses.color_pair(4))
        stdscr.addnstr(h - 1, 2, footer.ljust(w - 4), w - 4)
        stdscr.attroff(curses.color_pair(4))
        
        # Show search bar if in search mode
        if search_mode or search_query:
            search_text = f"Search: {search_query}_" if search_mode else f"Filter: {search_query} ({len(filtered_channels)} channels)"
            stdscr.attron(curses.color_pair(1))
            stdscr.addnstr(h - 2, 2, search_text[:w - 4], w - 4)
            stdscr.attroff(curses.color_pair(1))

        key = stdscr.getch()

        if key in (ord('q'),) and not search_mode:
            break
        elif key == ord('/') and not search_mode:
            # Enter search mode
            search_mode = True
            search_query = ""
            curses.curs_set(1)  # Show cursor
        elif key == 27:  # ESC key
            # Exit search mode and clear filter
            search_mode = False
            search_query = ""
            filtered_channels = channels[:]
            selected = 0
            scroll = 0
            curses.curs_set(0)  # Hide cursor
        elif search_mode:
            # Handle search input
            if key == curses.KEY_BACKSPACE or key == 127 or key == 8:
                search_query = search_query[:-1]
            elif key == 10 or key == 13:  # Enter key
                # Exit search mode but keep filter
                search_mode = False
                curses.curs_set(0)
            elif 32 <= key <= 126:  # Printable characters
                search_query += chr(key)
            
            # Filter channels based on query
            if search_query:
                query_lower = search_query.lower()
                filtered_channels = []
                for ch in channels:
                    # Search in channel number, name, and current program
                    channel_num = str(ch['GuideNumber']).lower()
                    channel_name = ch['GuideName'].lower()
                    current_prog = channel_programs_cache.get(ch["GuideNumber"], "").lower()
                    
                    if (query_lower in channel_num or 
                        query_lower in channel_name or 
                        query_lower in current_prog):
                        filtered_channels.append(ch)
                
                # Reset selection if filter changed
                selected = 0
                scroll = 0
            else:
                filtered_channels = channels[:]
        elif key == curses.KEY_UP:
            selected = max(0, selected - 1)
        elif key == curses.KEY_DOWN:
            selected = min(len(display_channels) - 1, selected + 1)
        elif key in (10, 13):
            launch_mpv(display_channels[selected]["GuideNumber"])
        elif key == ord('b') and not search_mode:
            if LAST_CHANNEL is not None:
                # Find last channel in full channel list
                for i, ch in enumerate(channels):
                    if ch["GuideNumber"] == LAST_CHANNEL:
                        # update selection in current display list if visible
                        for j, dch in enumerate(display_channels):
                            if dch["GuideNumber"] == LAST_CHANNEL:
                                selected = j
                                break

                        launch_mpv(LAST_CHANNEL)
                        break


        stdscr.refresh()


if __name__ == "__main__":
    curses.wrapper(main)